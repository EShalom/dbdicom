

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dbdicom.types.series &#8212; dbdicom 1.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/design-tabs.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/dbdicom/types/series';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  <div class="navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/dbd.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../../_static/dbd.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
    
  </div>
  
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../user_guide/index.html">
                        User guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../reference/index.html">
                        Reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../tutorials/index.html">
                        Tutorials
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../developers_guide/index.html">
                        Developer guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../about/index.html">
                        About
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/QIB-Sheffield/dbdicom" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-square-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
    </div>
  

  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../user_guide/index.html">
                        User guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../reference/index.html">
                        Reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../tutorials/index.html">
                        Tutorials
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../developers_guide/index.html">
                        Developer guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../about/index.html">
                        About
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/QIB-Sheffield/dbdicom" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-square-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumbs">
  <ul class="bd-breadcrumbs" role="navigation" aria-label="Breadcrumb">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">dbdicom.types.series</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for dbdicom.types.series</h1><div class="highlight"><pre>
<span></span><span class="c1"># Importing annotations to handle or sign in import type hints</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>

<span class="kn">from</span> <span class="nn">dbdicom.record</span> <span class="kn">import</span> <span class="n">Record</span><span class="p">,</span> <span class="n">read_dataframe_from_instance_array</span>
<span class="kn">from</span> <span class="nn">dbdicom.ds</span> <span class="kn">import</span> <span class="n">MRImage</span>
<span class="kn">import</span> <span class="nn">dbdicom.utils.image</span> <span class="k">as</span> <span class="nn">image_utils</span>
<span class="kn">from</span> <span class="nn">dbdicom.manager</span> <span class="kn">import</span> <span class="n">Manager</span>
<span class="c1"># import dbdicom.wrappers.scipy as scipy_utils</span>
<span class="kn">from</span> <span class="nn">dbdicom.utils.files</span> <span class="kn">import</span> <span class="n">export_path</span>


<span class="k">class</span> <span class="nc">Series</span><span class="p">(</span><span class="n">Record</span><span class="p">):</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;SeriesInstanceUID&#39;</span>

    <span class="k">def</span> <span class="nf">_set_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">delete_series</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#uid = self.manager.register.at[self.key(), &#39;StudyInstanceUID&#39;]</span>
        <span class="n">uid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(),</span> <span class="s1">&#39;StudyInstanceUID&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;Study&#39;</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 
        <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_instance</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_sibling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(),</span> <span class="s1">&#39;SeriesDescription&#39;</span><span class="p">)</span> 
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;SeriesDescription&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">+</span> <span class="s1">&#39; [&#39;</span> <span class="o">+</span> <span class="n">suffix</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">new_child</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">}</span>
        <span class="n">uid</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">new_instance</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(),</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;Instance&#39;</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>

    <span class="c1"># replace by clone(). Adopt implies move rather than copy</span>
    <span class="k">def</span> <span class="nf">adopt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instances</span><span class="p">):</span> 
        <span class="n">uids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">uid</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">]</span>
        <span class="n">uids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">copy_to_series</span><span class="p">(</span><span class="n">uids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uids</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;Instance&#39;</span><span class="p">,</span> <span class="n">uid</span><span class="p">)</span> <span class="k">for</span> <span class="n">uid</span> <span class="ow">in</span> <span class="n">uids</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;Instance&#39;</span><span class="p">,</span> <span class="n">uids</span><span class="p">)</span>        

    <span class="k">def</span> <span class="nf">_copy_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">}</span>
        <span class="n">uids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">copy_to_series</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uids</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;Instance&#39;</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">uid</span> <span class="ow">in</span> <span class="n">uids</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;Instance&#39;</span><span class="p">,</span> <span class="n">uids</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>





    <span class="k">def</span> <span class="nf">export_as_dicom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span> 
        <span class="n">folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">export_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
        <span class="c1"># Create a copy so that exported datasets have different UIDs.</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mgr</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
        <span class="n">mgr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">copy</span><span class="o">.</span><span class="n">instances</span><span class="p">():</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">get_dataset</span><span class="p">()</span>
            <span class="n">mgr</span><span class="o">.</span><span class="n">import_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
        <span class="n">copy</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">export_as_png</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">#Export all images as png files</span>
        <span class="n">folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">export_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
            <span class="n">img</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="s1">&#39;Exporting png..&#39;</span><span class="p">)</span>
            <span class="n">img</span><span class="o">.</span><span class="n">export_as_png</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">export_as_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="c1">#Export all images as csv files</span>
        <span class="n">folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">export_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
            <span class="n">img</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="s1">&#39;Exporting csv..&#39;</span><span class="p">)</span>
            <span class="n">img</span><span class="o">.</span><span class="n">export_as_csv</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">export_as_npy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">export_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
            <span class="n">images</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
                <span class="n">img</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="s1">&#39;Exporting npy..&#39;</span><span class="p">)</span>
                <span class="n">img</span><span class="o">.</span><span class="n">export_as_npy</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filepath</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">export_as_nifti</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">export_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine_matrix</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">affine</span> <span class="o">=</span> <span class="p">[</span><span class="n">affine</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">affine</span><span class="p">:</span>
                <span class="n">matrix</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">images</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
                    <span class="n">img</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="s1">&#39;Exporting nifti..&#39;</span><span class="p">)</span>
                    <span class="n">img</span><span class="o">.</span><span class="n">export_as_nifti</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">get_dataset</span><span class="p">()</span>
            <span class="n">sgroups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_groups</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sgroups</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sgroups</span><span class="p">),</span> <span class="s1">&#39;Exporting nifti..&#39;</span><span class="p">)</span>
                <span class="n">dicom_header</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">Nifti1DicomExtension</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span>
                <span class="n">nifti1_image</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">(</span><span class="n">sg</span><span class="p">[</span><span class="s1">&#39;ndarray&#39;</span><span class="p">],</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">affine_to_RAH</span><span class="p">(</span><span class="n">sg</span><span class="p">[</span><span class="s1">&#39;affine&#39;</span><span class="p">]))</span>
                <span class="n">nifti1_image</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">extensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dicom_header</span><span class="p">)</span>
                <span class="n">filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
                <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filepath</span> <span class="o">+</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;].nii&#39;</span><span class="p">)</span>
                <span class="n">nib</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">nifti1_image</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">import_dicom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
        <span class="n">uids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">import_datasets</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">move_to</span><span class="p">(</span><span class="n">uids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">)</span>



<div class="viewcode-block" id="Series.subseries"><a class="viewcode-back" href="../../../reference/generated/dbdicom.Series.subseries.html#dbdicom.Series.subseries">[docs]</a>    <span class="k">def</span> <span class="nf">subseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract a subseries based on values of header elements.</span>

<span class="sd">        Args:</span>
<span class="sd">            kwargs: Any number of valid DICOM (tag, value) keyword arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Series: a new series as a sibling under the same parent.</span>

<span class="sd">        See Also:</span>
<span class="sd">            :func:`~split_by`</span>

<span class="sd">        Example:</span>

<span class="sd">            Create a multi-slice series with multiple flip angles and repetition times:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...    &#39;SliceLocation&#39;: np.arange(16),</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: [2, 15, 30],</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: [2.5, 5.0, 7.5],</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128, 128, 16, 3, 2), coords)</span>

<span class="sd">            Create a new series containing only the data with flip angle 2 and repetition time 7.5:</span>

<span class="sd">            &gt;&gt;&gt; volume = zeros.subseries(FlipAngle=2.0, RepetitionTime=7.5)</span>

<span class="sd">            Check that the volume series now has two dimensions of size 1:</span>

<span class="sd">            &gt;&gt;&gt; array = volume.ndarray(dims=tuple(coords))</span>
<span class="sd">            &gt;&gt;&gt; print(array.shape)</span>
<span class="sd">            (128, 128, 16, 1, 1)</span>

<span class="sd">            and only one flip angle and repetition time:</span>

<span class="sd">            &gt;&gt;&gt; print(volume.FlipAngle, volume.RepetitionTime)</span>
<span class="sd">            2.0 7.5</span>

<span class="sd">            and that the parent study now has two series:</span>

<span class="sd">            &gt;&gt;&gt; volume.study().print()</span>
<span class="sd">            ---------- STUDY ---------------</span>
<span class="sd">            Study New Study [None]</span>
<span class="sd">            Series 001 [New Series]</span>
<span class="sd">                Nr of instances: 96</span>
<span class="sd">            Series 002 [New Series]</span>
<span class="sd">                Nr of instances: 16</span>
<span class="sd">            --------------------------------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">subseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">move</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Series.split_by"><a class="viewcode-back" href="../../../reference/generated/dbdicom.Series.split_by.html#dbdicom.Series.split_by">[docs]</a>    <span class="k">def</span> <span class="nf">split_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split the series into multiple subseries based on keyword value.</span>

<span class="sd">        Args:</span>
<span class="sd">            keyword (str | tuple): A valid DICOM keyword or hexadecimal (group, element) tag.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if an invalid or missing keyword is provided.</span>
<span class="sd">            ValueError: if all images have the same value for the keyword, so no subseries can be derived. An exception is raised rather than a copy of the series to avoid unnecessary copies being made. If that is the intention, use series.copy() instead.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of ``Series`` instances, where each element has the same value of the given keyword.</span>

<span class="sd">        See Also:</span>
<span class="sd">            :func:`~subseries`</span>

<span class="sd">        Example: </span>

<span class="sd">            Create a single-slice series with multiple flip angles and repetition times:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: [2, 15, 30],</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: [2.5, 7.5],</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128, 128, 3, 2), coords)</span>
<span class="sd">            &gt;&gt;&gt; zeros.print()</span>
<span class="sd">            ---------- SERIES --------------</span>
<span class="sd">            Series 001 [New Series]</span>
<span class="sd">                Nr of instances: 6</span>
<span class="sd">                    MRImage 000001</span>
<span class="sd">                    MRImage 000002</span>
<span class="sd">                    MRImage 000003</span>
<span class="sd">                    MRImage 000004</span>
<span class="sd">                    MRImage 000005</span>
<span class="sd">                    MRImage 000006</span>
<span class="sd">            --------------------------------</span>

<span class="sd">            Splitting this series by FlipAngle now creates 3 new series in the same study, with 2 images each. By default the fixed value of the splitting attribute is written in the series description:</span>

<span class="sd">            &gt;&gt;&gt; FA = zeros.split_by(&#39;FlipAngle&#39;)</span>
<span class="sd">            &gt;&gt;&gt; zeros.study().print()</span>
<span class="sd">            ---------- STUDY ---------------</span>
<span class="sd">            Study New Study [None]</span>
<span class="sd">                Series 001 [New Series]</span>
<span class="sd">                    Nr of instances: 6</span>
<span class="sd">                Series 002 [New Series[FlipAngle = 2.0]]</span>
<span class="sd">                    Nr of instances: 2</span>
<span class="sd">                Series 003 [New Series[FlipAngle = 15.0]]</span>
<span class="sd">                    Nr of instances: 2</span>
<span class="sd">                Series 004 [New Series[FlipAngle = 30.0]]</span>
<span class="sd">                    Nr of instances: 2</span>
<span class="sd">            --------------------------------</span>

<span class="sd">            Check the flip angle of the split series:</span>
<span class="sd">            &gt;&gt;&gt; for series in FA: </span>
<span class="sd">            ...     print(series.FlipAngle)</span>
<span class="sd">            2.0</span>
<span class="sd">            15.0</span>
<span class="sd">            30.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Reading values..&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; is not a valid DICOM keyword&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot split by &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> 
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;All images have the same value&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>   
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot split by &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> 
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;All images have the same value&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Splitting series..&#39;</span><span class="p">)</span>
        <span class="n">split_series</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span> <span class="o">+</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="n">keyword</span> <span class="o">+</span> <span class="s1">&#39; = &#39;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">keyword</span><span class="p">:</span> <span class="n">v</span><span class="p">}</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subseries</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
            <span class="n">split_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">split_series</span></div>


    <span class="c1"># TODO: This needs the same API as ndarray with coord and slice arguments.</span>
    <span class="c1"># TODO: This also needs a set_slice_group.</span>
    <span class="c1"># TODO: Currently based on image orientation only rather than complete affine.</span>
<div class="viewcode-block" id="Series.slice_groups"><a class="viewcode-back" href="../../../reference/generated/dbdicom.Series.slice_groups.html#dbdicom.Series.slice_groups">[docs]</a>    <span class="k">def</span> <span class="nf">slice_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,))</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of slice groups in the series.</span>

<span class="sd">        In dbdicom, a *slice group* is defined as a series of slices that have the same orientation. It is common for a single series to have images with multiple orientations, such as in localizer series in MRI. For such a series, returning all data in a single array may not be meaningful. </span>

<span class="sd">        Formally, a *slice group* is a dictionary with two entries: &#39;ndarray&#39; is the numpy.ndarray with the data along the dimensions provided by the dims argument, and &#39;affine&#39; is the 4x4 affine matrix of the slice group. The function returns a list of such dictionaries, one for each slice group in the series.</span>

<span class="sd">        Args:</span>
<span class="sd">            dims (tuple, optional): Dimensions for the returned arrays. Defaults to (&#39;InstanceNumber&#39;,).</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of slice groups (dictionaries), one for each slice group in the series.</span>

<span class="sd">        Examples:</span>

<span class="sd">            &gt;&gt;&gt; series = db.ones((128,128,5,10))</span>
<span class="sd">            &gt;&gt;&gt; sgroups = series.slice_groups(dims=(&#39;SliceLocation&#39;, &#39;AcquisitionTime&#39;))</span>

<span class="sd">            Since there is only one slice group in the series, ``sgroups`` is a list with one element:</span>

<span class="sd">            &gt;&gt;&gt; print(len(sgroups))</span>
<span class="sd">            1</span>

<span class="sd">            The array of the slice group is the entire volume of the series:</span>

<span class="sd">            &gt;&gt;&gt; print(sgroups[0][&#39;ndarray&#39;].shape)</span>
<span class="sd">            (128, 128, 5, 10)</span>

<span class="sd">            And the affine of the series has not changed from the default (identity):</span>

<span class="sd">            &gt;&gt;&gt; print(sgroups[0][&#39;affine&#39;])</span>
<span class="sd">            [[1. 0. 0. 0.]</span>
<span class="sd">             [0. 1. 0. 0.]</span>
<span class="sd">             [0. 0. 1. 0.]</span>
<span class="sd">             [0. 0. 0. 1.]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">slice_groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">image_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ImageOrientationPatient</span>

        <span class="c1"># Multiple slice groups in series - return list of cuboids</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">image_orientation</span><span class="p">:</span>
                <span class="n">slice_group</span> <span class="o">=</span> <span class="n">instance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ImageOrientationPatient</span><span class="o">=</span><span class="nb">dir</span><span class="p">)</span>
                <span class="n">affine</span> <span class="o">=</span> <span class="n">_slice_group_affine_matrix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">slice_group</span><span class="p">),</span> <span class="nb">dir</span><span class="p">)</span>
                <span class="n">array</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_pixel_array_from_instance_array</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">slice_groups</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;ndarray&#39;</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;affine&#39;</span><span class="p">:</span> <span class="n">affine</span><span class="p">})</span>
        
        <span class="c1"># Single slice group in series - return a list with a single affine matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slice_group</span> <span class="o">=</span> <span class="n">instance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">_slice_group_affine_matrix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">slice_group</span><span class="p">),</span> <span class="n">image_orientation</span><span class="p">)</span>
            <span class="n">array</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_pixel_array_from_instance_array</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">slice_groups</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;ndarray&#39;</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;affine&#39;</span><span class="p">:</span> <span class="n">affine</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">slice_groups</span></div>
        

<div class="viewcode-block" id="Series.affine"><a class="viewcode-back" href="../../../reference/generated/dbdicom.Series.affine.html#dbdicom.Series.affine">[docs]</a>    <span class="k">def</span> <span class="nf">affine</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of unique affine matrices in the series</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the file is corrupted and necessary DICOM attributes are not included.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: list of 4x4 ndarrays with the unique affine matrices of the series.</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`~set_affine`</span>

<span class="sd">        Example:</span>
<span class="sd">            Check that the default affine is the identity:</span>

<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128,128,10))</span>
<span class="sd">            &gt;&gt;&gt; print(zeros.affine())</span>
<span class="sd">            [array([</span>
<span class="sd">                [1., 0., 0., 0.],</span>
<span class="sd">                [0., 1., 0., 0.],</span>
<span class="sd">                [0., 0., 1., 0.],</span>
<span class="sd">                [0., 0., 0., 1.]], dtype=float32)]</span>

<span class="sd">            Note this is a list of one single element as the series only has a single slice group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">image_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ImageOrientationPatient</span>
        <span class="k">if</span> <span class="n">image_orientation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;ImageOrientationPatient not defined in the DICOM header </span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This is a required DICOM field </span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;The data may be corrupted - please check&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Multiple slice groups in series - return list of affine matrices</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">affine_matrices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">image_orientation</span><span class="p">:</span>
                <span class="n">slice_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="n">ImageOrientationPatient</span><span class="o">=</span><span class="nb">dir</span><span class="p">)</span>
                <span class="n">affine</span> <span class="o">=</span> <span class="n">_slice_group_affine_matrix</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
                <span class="n">affine_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">affine</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">affine_matrices</span>
        <span class="c1"># Single slice group in series - return a list with a single affine matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slice_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">()</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">_slice_group_affine_matrix</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="n">image_orientation</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">affine</span><span class="p">]</span></div>


<div class="viewcode-block" id="Series.set_affine"><a class="viewcode-back" href="../../../reference/generated/dbdicom.Series.set_affine.html#dbdicom.Series.set_affine">[docs]</a>    <span class="k">def</span> <span class="nf">set_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">affine</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the affine matrix of a series.</span>

<span class="sd">        The affine is defined as a 4x4 numpy array with bottom row [0,0,0,1]. The final column represents the position of the top right hand corner of the first slice. The first three columns represent rotation and scaling with respect to the axes of the reference frame.</span>

<span class="sd">        Args:</span>
<span class="sd">            affine (numpy.ndarray): 4x4 numpy array </span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the series is empty. The information of the affine matrix is stored in the header and can not be stored in an empty series.</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`~affine`</span>

<span class="sd">        Example:</span>
<span class="sd">            Create a series with unit affine array:</span>

<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128,128,10))</span>
<span class="sd">            &gt;&gt;&gt; print(zeros.affine())</span>
<span class="sd">            [array([</span>
<span class="sd">                [1., 0., 0., 0.],</span>
<span class="sd">                [0., 1., 0., 0.],</span>
<span class="sd">                [0., 0., 1., 0.],</span>
<span class="sd">                [0., 0., 0., 1.]], dtype=float32)]</span>

<span class="sd">            Rotate the volume over 90 degrees in the xy-plane:</span>

<span class="sd">            &gt;&gt;&gt; affine = np.array([</span>
<span class="sd">            ... [1., 0., 0., 0.],</span>
<span class="sd">            ... [0., 1., 0., 0.],</span>
<span class="sd">            ... [0., 0., 1., 0.],</span>
<span class="sd">            ... [0., 0., 0., 1.],</span>
<span class="sd">            ... ]) </span>
<span class="sd">            &gt;&gt;&gt; zeros.set_affine(affine)</span>

<span class="sd">            Apart from the rotation, also change the resolution to (3mm, 3mm, 1.5mm):</span>

<span class="sd">            &gt;&gt;&gt; affine = np.array([</span>
<span class="sd">            ... [0., -3., 0., 0.],</span>
<span class="sd">            ... [3., 0., 0., 0.],</span>
<span class="sd">            ... [0., 0., 1.5, 0.],</span>
<span class="sd">            ... [0., 0., 0., 1.],</span>
<span class="sd">            ... ])  </span>
<span class="sd">            &gt;&gt;&gt; zeros.set_affine(affine)</span>

<span class="sd">            # Now rotate, change resolution, and shift the top right hand corner of the lowest slice to position (-30mm, 20mm, 120mm):</span>

<span class="sd">            &gt;&gt;&gt; affine = np.array([</span>
<span class="sd">            ... [0., -3., 0., -30.],</span>
<span class="sd">            ... [3., 0., 0., 20.],</span>
<span class="sd">            ... [0., 0., 1.5, 120.],</span>
<span class="sd">            ... [0., 0., 0., 1.],</span>
<span class="sd">            ... ])  </span>
<span class="sd">            &gt;&gt;&gt; zeros.set_affine(affine)</span>

<span class="sd">            Note changing the affine will affect multiple DICOM tags, such as slice location and image positions:</span>

<span class="sd">            &gt;&gt;&gt; print(zeros.SliceLocation)</span>
<span class="sd">            [120.0, 121.5, 123.0, 124.5, 126.0, 127.5, 129.0, 130.5, 132.0, 133.5]</span>

<span class="sd">            In this case, since the slices are stacked in parallel to the z-axis, the slice location starts at the lower z-coordinate of 120mm and then increments slice-by-slice with the slice thickness of 1.5mm.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">instance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">images</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot set affine matrix in an empty series </span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Set some data with series.ndarray() and then try again.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">affine_z</span> <span class="o">=</span> <span class="n">affine</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># For each slice location, the slice position needs to be updated too</span>
        <span class="c1"># Need the coordinates of the vector parallel to the z-axis of the volume.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">dismantle_affine_matrix</span><span class="p">(</span><span class="n">affine</span><span class="p">)</span>
        <span class="n">ez</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="s1">&#39;SpacingBetweenSlices&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;slice_cosine&#39;</span><span class="p">])</span>

        <span class="c1"># Set the affine slice-by-slice</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="s1">&#39;Writing affine..&#39;</span><span class="p">)</span>
            <span class="n">affine_z</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">affine</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">ez</span>
            <span class="n">images</span><span class="p">[</span><span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">images</span><span class="p">[</span><span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">affine_matrix</span> <span class="o">=</span> <span class="n">affine_z</span>
            <span class="n">images</span><span class="p">[</span><span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

        

<div class="viewcode-block" id="Series.ndarray"><a class="viewcode-back" href="../../../reference/generated/dbdicom.Series.ndarray.html#dbdicom.Series.ndarray">[docs]</a>    <span class="k">def</span> <span class="nf">ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,),</span> <span class="n">coords</span><span class="p">:</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">slice</span><span class="p">:</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a numpy.ndarray with pixel data.</span>

<span class="sd">        Args:</span>
<span class="sd">            dims (tuple, optional): Dimensions of the result, as a tuple of valid DICOM tags of any length. Defaults to (&#39;InstanceNumber&#39;,).</span>
<span class="sd">            coords (dict, optional): Dictionary with coordinates to retrieve a slice of the entire array. If coords is provided, the dims argument is ignored.</span>
<span class="sd">            slice (dict, optional): Dictionary with coordinates to retrieve a slice of the entire array. If slice is provided, then the dims argument is ignored. The difference with coords is that the dictionary values in slice specify the indices rather than the values of the coordinates.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: pixel data. The number of dimensions will be 2 plus the number of elements in dim, or the number of entries in slice or islice. The first two indices will enumerate (x,y) coordinates in the slice, the other dimensions are as specified by the dims, slice or islice argument. </span>
<span class="sd">            </span>
<span class="sd">            The function returns an empty array when no data are found at the specified slices.</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`~set_ndarray`</span>

<span class="sd">        Example:</span>
<span class="sd">            Create a zero-filled array, describing 8 MRI slices (10mm apart) each measured at 3 flip angles and 2 repetition times:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...    &#39;SliceLocation&#39;: 10*np.arange(8),</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: [2, 15, 30],</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: [2.5, 5.0],</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128,128,8,3,2), coords)</span>

<span class="sd">            To retrieve the array, the dimensions need to be provided:</span>

<span class="sd">            &gt;&gt;&gt; dims = (&#39;SliceLocation&#39;, &#39;FlipAngle&#39;, &#39;RepetitionTime&#39;)</span>
<span class="sd">            &gt;&gt;&gt; array = zeros.ndarray(dims)</span>
<span class="sd">            &gt;&gt;&gt; print(array.shape)</span>
<span class="sd">            (128, 128, 8, 3, 2)</span>

<span class="sd">            Note the dimensions are the keys of the coordinate dictionary, so this could also have been called as:</span>

<span class="sd">            &gt;&gt;&gt; array = zeros.ndarray(dims=tuple(coords)) </span>
<span class="sd">            &gt;&gt;&gt; print(array.shape)</span>
<span class="sd">            (128, 128, 8, 3, 2)</span>

<span class="sd">            To retrieve a slice of the volume, specify the coordinates of the slice as a dictionary. For instance, to retrieve the pixel data measured with a flip angle of 15:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...    &#39;SliceLocation&#39;: 10*np.arange(8),</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: [15],</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: [2.5, 5.0],</span>
<span class="sd">            ... }</span>

<span class="sd">            Now pass this as coordinates in the call to ndarray:</span>

<span class="sd">            &gt;&gt;&gt; array = zeros.ndarray(coords=coords) </span>
<span class="sd">            &gt;&gt;&gt; print(array.shape)</span>
<span class="sd">            (128, 128, 8, 1, 2)</span>

<span class="sd">            A slice can also be specified with indices rather than absolute values of the coordinates:</span>

<span class="sd">            &gt;&gt;&gt; slice = {</span>
<span class="sd">            ...    &#39;SliceLocation&#39;: np.arange(8),</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: [1],</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: np.arange(2),</span>
<span class="sd">            ... }</span>

<span class="sd">            Now pass this as index coordinates in the call to ndarray:</span>

<span class="sd">            &gt;&gt;&gt; array = zeros.ndarray(slice=slice) </span>
<span class="sd">            &gt;&gt;&gt; print(array.shape)</span>
<span class="sd">            (128, 128, 8, 1, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">instance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">if</span> <span class="nb">slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">slice</span><span class="p">):</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="p">]):</span>
                    <span class="n">si</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">si</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">dim</span><span class="p">]</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]:</span>
                        <span class="n">ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">array</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">instances</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">im</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instances</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">im</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">im</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instances</span><span class="p">),</span> <span class="s1">&#39;Reading pixel data..&#39;</span><span class="p">)</span>
                <span class="n">array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_pixel_array</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">im</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">hide</span><span class="p">()</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">_stack</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="c1"># Move pixel coordinates to front</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span></div>
    

<div class="viewcode-block" id="Series.set_ndarray"><a class="viewcode-back" href="../../../reference/generated/dbdicom.Series.set_ndarray.html#dbdicom.Series.set_ndarray">[docs]</a>    <span class="k">def</span> <span class="nf">set_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">coords</span><span class="p">:</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">slice</span><span class="p">:</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign new pixel data with a new numpy.ndarray. </span>

<span class="sd">        Args:</span>
<span class="sd">            array (np.ndarray): array with new pixel data.</span>
<span class="sd">            coords (dict, optional): Provide coordinates for the array, using a dictionary where the keys list the dimensions, and the values are provided as 1D or meshgrid arrays of coordinates. If data already exist at the specified coordinates, these will be overwritten. If not, the new data will be added to the series.</span>
<span class="sd">            slice (dict, optional): Provide a slice of existing data that will be overwritten with the new array. The format is the same as the dictionary of coordinates, except that the slice is identified by indices rather than values. </span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if neither coords or slice or provided, if both are provided, or if the dimensions in coords or slice does not match up with the dimensions of the array.</span>
<span class="sd">            IndexError: when attempting to set a slice in an empty array, or when the indices in slice are out of range of the existing coordinates. </span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`~ndarray`</span>

<span class="sd">        Example:</span>
<span class="sd">            Create a zero-filled array, describing 8 MRI slices each measured at 3 flip angles and 2 repetition times:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...    &#39;SliceLocation&#39;: np.arange(8),</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: [2, 15, 30],</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: [2.5, 5.0],</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series = db.zeros((128,128,8,3,2), coords)</span>

<span class="sd">            Retrieve the array and check that it is populated with zeros:</span>

<span class="sd">            &gt;&gt;&gt; array = series.ndarray(dims=tuple(coords)) </span>
<span class="sd">            &gt;&gt;&gt; print(np.mean(array))</span>
<span class="sd">            0.0</span>

<span class="sd">            Now overwrite the values with a new array of ones in a new shape:</span>

<span class="sd">            &gt;&gt;&gt; new_shape = (128,128,8)</span>
<span class="sd">            &gt;&gt;&gt; new_coords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.arange(8),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; ones = np.ones(new_shape)</span>
<span class="sd">            &gt;&gt;&gt; series.set_ndarray(ones, coords=new_coords)</span>

<span class="sd">            Retrieve the new array and check shape:</span>
<span class="sd">            </span>
<span class="sd">            &gt;&gt;&gt; array = series.ndarray(dims=tuple(new_coords))</span>
<span class="sd">            &gt;&gt;&gt; print(array.shape)</span>
<span class="sd">            (128,128,8)</span>

<span class="sd">            Check that the value is overwritten:</span>

<span class="sd">            &gt;&gt;&gt; print(np.mean(array))</span>
<span class="sd">            1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># TODO: set_pixel_array has **kwargs to allow setting other properties on the fly to save extra reading and writing. This makes sense but should be handled by a more general function, such as:</span>
        <span class="c1"># #  </span>
        <span class="c1"># series.set(ndarray:np.ndarray, coords:dict, affine:np.ndarray, **kwargs)</span>
        <span class="c1"># #</span>

        <span class="c1"># Check whether the arguments are valid, and initialize dims.</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;One coordinate must be specified for each dimensions in the array.&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="o">+</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; in the coords must have the same number of elements as the corresponding dimension in the array&#39;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;One coordinate must be specified for each dimensions in the array.&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;At least one of the optional arguments coords or slice must be provided&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cnt</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Only one of the optional arguments coords or slice must be provided&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">source</span> <span class="o">=</span> <span class="n">instance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Retrieve the instances corresponding to the coordinates.</span>
            <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="p">]):</span>
                        <span class="n">si</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">si</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">dim</span><span class="p">]</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]:</span>
                            <span class="n">ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Retrieve the instances of the slice, as well as their coordinates.</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">slice</span><span class="p">):</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;The indices for &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; in the slice argument are out of bounds&#39;</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="p">]):</span>
                    <span class="n">si</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                    <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">si</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">dim</span><span class="p">])</span>  

        <span class="n">nr_of_slices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
        <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If there are not yet any instances at the correct coordinates, they will be created from scratch</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">new_instance</span><span class="p">(</span><span class="n">MRImage</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_of_slices</span><span class="p">)]</span>
            <span class="n">set_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="c1"># If the new array has the same shape, use the exact headers.</span>
            <span class="n">set_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the new array has a different shape, use the first header for all and delete all the others</span>
            <span class="c1"># This happens when some of the new coordinates are present, but not all.</span>
            <span class="c1"># TODO: This is overkill - only fill in the gaps with copies.</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">series</span> <span class="ow">in</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">series</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_of_slices</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">set_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span></div>


    <span class="c1">#</span>
    <span class="c1"># Following APIs are obsolete and will be removed in future versions</span>
    <span class="c1">#</span>


    <span class="c1"># def slice_groups(*args, **kwargs):</span>
    <span class="c1">#     return slice_groups(*args, **kwargs)</span>
    
    <span class="k">def</span> <span class="nf">affine_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">affine_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">get_pixel_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">set_pixel_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_pixel_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 
        <span class="k">return</span> <span class="n">get_pixel_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_pixel_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">set_pixel_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">set_ndarray</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 

    <span class="c1"># If coordinates are given as 1D arrays, turn them into grids and flatten for iteration.</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh_coords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># regular grid</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                    <span class="n">mesh_coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="c1"># Flatten array for iterating</span>
    <span class="n">nr_of_slices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nr_of_slices</span><span class="p">))</span> <span class="c1"># shape (x,y,i)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="n">series</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="s1">&#39;Saving array..&#39;</span><span class="p">)</span>
        <span class="n">image</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="c1"># If needed, use Defaults for geometry markers</span>
        <span class="k">if</span> <span class="n">affine</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">affine</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">image</span><span class="o">.</span><span class="n">affine_matrix</span> <span class="o">=</span> <span class="n">affine</span>

        <span class="c1"># Update any other header data provided</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> 
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>

        <span class="c1"># Set coordinates.</span>
        <span class="k">if</span> <span class="n">mesh_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">mesh_coords</span><span class="p">:</span>
                <span class="n">image</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh_coords</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> 

        <span class="n">image</span><span class="o">.</span><span class="n">set_pixel_array</span><span class="p">(</span><span class="n">array</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">])</span>
        <span class="n">image</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>


<span class="c1"># def slice_groups(series): # not yet in use</span>
<span class="c1">#     slice_groups = []</span>
<span class="c1">#     for orientation in series.ImageOrientationPatient:</span>
<span class="c1">#         sg = series.instances(ImageOrientationPatient=orientation)</span>
<span class="c1">#         slice_groups.append(sg)</span>
<span class="c1">#     return slice_groups</span>


<span class="k">def</span> <span class="nf">subseries</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">move</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">series</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">()</span>
    <span class="n">instances</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instances</span><span class="p">):</span>
        <span class="n">record</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instances</span><span class="p">),</span> <span class="s1">&#39;Extracting subseries..&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">move</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">move_to</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
    <span class="c1"># This should be faster:</span>
    <span class="c1"># instances = record.instances(**kwargs)</span>
    <span class="c1"># series.adopt(instances)</span>
    <span class="k">return</span> <span class="n">series</span>


<span class="k">def</span> <span class="nf">read_npy</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
    <span class="c1"># Not in use - loading of temporary numpy files</span>
    <span class="n">file</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">npy</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array</span>



<span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="c1"># array of instances</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">record</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rec</span>
        <span class="k">return</span> <span class="n">_get_pixel_array_from_instance_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="n">sortby</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="n">pixels_first</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="n">first_volume</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="c1"># array of instances</span>
        <span class="k">return</span> <span class="n">_get_pixel_array_from_instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="n">sortby</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="n">pixels_first</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="n">first_volume</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">get_pixel_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="n">sortby</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="n">pixels_first</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="n">first_volume</span><span class="p">)</span>
    

<span class="k">def</span> <span class="nf">get_pixel_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">sortby</span><span class="p">)</span>
    <span class="n">array</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">_get_pixel_array_from_sorted_instance_array</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="n">pixels_first</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">first_volume</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">headers</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">,</span> <span class="n">headers</span>


<span class="k">def</span> <span class="nf">_get_pixel_array_from_instance_array</span><span class="p">(</span><span class="n">instance_array</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">sort_instance_array</span><span class="p">(</span><span class="n">instance_array</span><span class="p">,</span> <span class="n">sortby</span><span class="p">)</span>
    <span class="n">array</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">_get_pixel_array_from_sorted_instance_array</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="n">pixels_first</span><span class="p">)</span> 
    <span class="k">if</span> <span class="n">first_volume</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">headers</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">,</span> <span class="n">headers</span>  


<span class="k">def</span> <span class="nf">_get_pixel_array_from_sorted_instance_array</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="n">array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">instances</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">im</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instances</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">im</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instances</span><span class="p">),</span> <span class="s1">&#39;Reading pixel data..&#39;</span><span class="p">)</span>
            <span class="n">array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_pixel_array</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">im</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">im</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">hide</span><span class="p">()</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">_stack</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Pixel array is empty. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Either because one or more of the keywords used for sorting does not exist; </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;or the series does not have any image data..&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">pixels_first</span><span class="p">:</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">,</span> <span class="n">source</span> 


<span class="k">def</span> <span class="nf">set_pixel_array</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 

    <span class="c1"># Move pixels to the end (default)</span>
    <span class="k">if</span> <span class="n">pixels_first</span><span class="p">:</span>    
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># if no header data are provided, use template headers.</span>
    <span class="n">nr_of_slices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">new_instance</span><span class="p">(</span><span class="n">MRImage</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_of_slices</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">new_instance</span><span class="p">(</span><span class="n">MRImage</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_of_slices</span><span class="p">)]</span>

    <span class="c1"># If the header data are not the same size, use only the first one.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># assume scalar</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">*</span> <span class="n">nr_of_slices</span>
        <span class="k">if</span> <span class="n">nr_of_slices</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">nr_of_slices</span>

    <span class="c1"># Copy all sources to the series, if they are not part of it</span>
    <span class="n">copy_source</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">instances</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">instances</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">:</span>
            <span class="n">copy_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">series</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="s1">&#39;Copying series..&#39;</span><span class="p">)</span>
            <span class="n">copy_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="n">series</span><span class="p">))</span>

    <span class="c1"># Faster but does not work if all sources are the same</span>
    <span class="c1"># series.status.message(&#39;Saving array (1/2): Copying series..&#39;)</span>
    <span class="c1"># instances = series.instances()</span>
    <span class="c1"># to_copy = [i for i in range(len(source)) if source[i] not in instances]</span>
    <span class="c1"># copied = series.adopt([source[i] for i in to_copy])</span>
    <span class="c1"># for i, c in enumerate(copied):</span>
    <span class="c1">#     source[to_copy[i]] = c</span>

    <span class="c1"># Flatten array for iterating</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nr_of_slices</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># shape (i,x,y)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">copy_source</span><span class="p">):</span>
        <span class="n">series</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">copy_source</span><span class="p">),</span> <span class="s1">&#39;Saving array..&#39;</span><span class="p">)</span>
        <span class="n">image</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> 
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
        <span class="n">image</span><span class="o">.</span><span class="n">set_pixel_array</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
        <span class="n">image</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>



<span class="k">def</span> <span class="nf">affine_matrix</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the affine matrix of a series.</span>
<span class="sd">    </span>
<span class="sd">    If the series consists of multiple slice groups with different </span>
<span class="sd">    image orientations, then a list of affine matrices is returned,</span>
<span class="sd">    one for each slice orientation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">image_orientation</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">ImageOrientationPatient</span>
    <span class="k">if</span> <span class="n">image_orientation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;ImageOrientationPatient not defined in the DICOM header </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;This is a required DICOM field </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;The data may be corrupted - please check&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="c1"># Multiple slice groups in series - return list of affine matrices</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">affine_matrices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">image_orientation</span><span class="p">:</span>
            <span class="n">slice_group</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="n">ImageOrientationPatient</span><span class="o">=</span><span class="nb">dir</span><span class="p">)</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">_slice_group_affine_matrix</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
            <span class="n">affine_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">affine</span><span class="p">,</span> <span class="n">slice_group</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">affine_matrices</span>
    <span class="c1"># Single slice group in series - return a single affine matrix</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">slice_group</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">instances</span><span class="p">()</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="n">_slice_group_affine_matrix</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="n">image_orientation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">affine</span><span class="p">,</span> <span class="n">slice_group</span>
    

<span class="k">def</span> <span class="nf">_slice_group_affine_matrix</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="n">image_orientation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the affine matrix of a slice group&quot;&quot;&quot;</span>

    <span class="c1"># single slice</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slice_group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">slice_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">affine_matrix</span>
    <span class="c1"># multi slice</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">ImagePositionPatient</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slice_group</span><span class="p">]</span>
        <span class="c1"># Find unique elements</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">pos</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>

        <span class="c1"># One slice location</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">slice_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">affine_matrix</span>
        
        <span class="c1"># Slices with different locations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">affine_matrix_multislice</span><span class="p">(</span>
                <span class="n">image_orientation</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
                <span class="n">slice_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">PixelSpacing</span><span class="p">)</span>    <span class="c1"># assume all the same pixel spacing</span>
        

<span class="k">def</span> <span class="nf">sort_instance_array</span><span class="p">(</span><span class="n">instance_array</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sortby</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">instance_array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">sortby</span> <span class="o">=</span> <span class="p">[</span><span class="n">sortby</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">read_dataframe_from_instance_array</span><span class="p">(</span><span class="n">instance_array</span><span class="p">,</span> <span class="n">sortby</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;SOPInstanceUID&#39;</span><span class="p">])</span>
        <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">df_to_sorted_instance_array</span><span class="p">(</span><span class="n">instance_array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">df</span><span class="p">,</span> <span class="n">sortby</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">status</span><span class="p">)</span>
        

<span class="k">def</span> <span class="nf">instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sort instances by a list of attributes.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        sortby: </span>
<span class="sd">            List of DICOM keywords by which the series is sorted</span>
<span class="sd">    Returns:</span>
<span class="sd">        An ndarray holding the instances sorted by sortby.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sortby</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">instances</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="o">**</span><span class="n">filters</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">instances</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instances</span><span class="p">):</span> 
            <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span>
        <span class="k">return</span> <span class="n">array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">sortby</span> <span class="o">=</span> <span class="p">[</span><span class="n">sortby</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">read_dataframe</span><span class="p">(</span><span class="n">sortby</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;SOPInstanceUID&#39;</span><span class="p">])</span> <span class="c1"># needs a **filters option</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">SOPInstanceUID</span><span class="o">.</span><span class="n">values</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">df_to_sorted_instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">sortby</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">status</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">df_to_sorted_instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">sortby</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> 
    <span class="c1"># note record here only passed for access to the function instance() and progress()</span>
    <span class="c1"># This really should be db.instance()</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">sortby</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">status</span><span class="p">:</span> 
            <span class="n">record</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;Sorting pixel data..&#39;</span><span class="p">)</span>
        <span class="c1"># if a type is not supported by np.isnan()</span>
        <span class="c1"># assume it is not a nan</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># this happens when undefined keywrod is used</span>
            <span class="n">dfc</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">sortby</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span> 
                <span class="n">nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span> 
                <span class="n">nan</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">nan</span><span class="p">:</span>
                <span class="n">dfc</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">sortby</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dfc</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">sortby</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="n">c</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortby</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">datac</span> <span class="o">=</span> <span class="n">df_to_instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">dfc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">datac</span> <span class="o">=</span> <span class="n">df_to_sorted_instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">dfc</span><span class="p">,</span> <span class="n">sortby</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">status</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">datac</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_stack</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">align_left</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">df_to_instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return datasets as numpy array of object type&quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">SOPInstanceUID</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">instance</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">align_left</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Stack a list of arrays of different shapes but same number of dimensions.</span>
<span class="sd">    </span>
<span class="sd">    This generalises numpy.stack to arrays of different sizes.</span>
<span class="sd">    The stack has the size of the largest array.</span>
<span class="sd">    If an array is smaller it is zero-padded and centred on the middle.</span>
<span class="sd">    None items are removed first before stacking</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get the dimensions of the stack</span>
    <span class="c1"># For each dimension, look for the largest values across all arrays</span>
    <span class="c1">#arrays = [a for a in arrays if a is not None]</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">arrays</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>
    <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="c1"># changing the variable we are iterating over!!</span>
    <span class="c1">#    for i in range(ndim):</span>
    <span class="c1">#        dim[i] = max((dim[i], array.shape[i]))</span>

    <span class="c1"># Create the stack</span>
    <span class="c1"># Add one dimension corresponding to the size of the stack</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="c1">#stack = np.full([n] + dim, 0, dtype=arrays[0].dtype)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dim</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">align_left</span><span class="p">:</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># align center and zero-pad missing values</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">d</span><span class="o">-</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span><span class="n">i1</span><span class="p">))</span>
        <span class="n">stack</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span> <span class="o">=</span> <span class="n">array</span>

    <span class="k">return</span> <span class="n">stack</span>







</pre></div>

                </article>
              
              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
       Copyright 2022, QIB-Sheffield.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.2.1.
    <br/>
  </p>
</div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.13.3.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>